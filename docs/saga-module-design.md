# Dise침o de Arquitectura: M칩dulo Reutilizable de Sagas y Eventos

-   **Estado:** 游닇 Propuesta Detallada
-   **Fecha:** 游늰 2025-07-29
-   **Autores:** Manuel Meneses, Asistente AI (Gemini)

## 1. Resumen Ejecutivo

Este documento describe la arquitectura de un m칩dulo NestJS reutilizable, `SagaEventModule`, dise침ado para estandarizar y simplificar la implementaci칩n de sistemas as칤ncronos basados en eventos y el patr칩n Saga (coreograf칤a).

El objetivo principal es **eliminar el c칩digo repetitivo (boilerplate)** y los errores humanos asociados a la gesti칩n de eventos, la propagaci칩n de metadatos de trazabilidad y la l칩gica de `try/catch`. La soluci칩n se centra en un sistema de **decoradores "m치gicos" pero declarativos** que automatizan estas tareas, permitiendo a los desarrolladores centrarse exclusivamente en la l칩gica de negocio.

## 2. Principios de Dise침o Clave

-   **Experiencia de Desarrollador (DX) Superior:** La API del m칩dulo debe ser intuitiva, expl칤cita y sentirse nativa del ecosistema NestJS. Se prioriza reducir la carga cognitiva del desarrollador.
-   **Magia Controlada y Expl칤cita:** El m칩dulo ocultar치 la complejidad, pero lo har치 de una manera predecible y declarativa. No habr치 "magia" que no pueda ser entendida leyendo las firmas de los decoradores.
-   **Trazabilidad de Extremo a Extremo como Requisito:** Cada acci칩n dentro del sistema debe ser rastreable a trav칠s de un `correlationId` 칰nico y un `causationId` que encadene los eventos, originados por un `actor` espec칤fico. Esta funcionalidad ser치 autom치tica y no opcional.
-   **Cero "Prop Drilling" Manual:** La propagaci칩n de metadatos de trazabilidad no ser치 responsabilidad del desarrollador. El m칩dulo se encargar치 de ello de forma transparente.

## 3. Arquitectura Detallada de Componentes

El m칩dulo se construir치 de forma autocontenida dentro de `src/saga-event-module` para esta prueba de concepto.

### 3.1. `RequestContextService`

-   **Prop칩sito:** Encapsular y gestionar el contexto de una transacci칩n 칰nica utilizando `AsyncLocalStorage` de Node.js.
-   **Implementaci칩n:**
    -   Contendr치 una instancia privada de `AsyncLocalStorage`.
    -   Expondr치 un m칠todo `run(callback)` que crea la "burbuja" de contexto para una petici칩n HTTP, un job, etc.
    -   Expondr치 m칠todos `set(key, value)` y `get(key)` para manipular los datos dentro del contexto actual.
-   **Uso:** Ser치 utilizado por un middleware global para establecer el contexto al inicio de cada petici칩n HTTP.

### 3.2. `EventMetadataHelper`

-   **Prop칩sito:** Servir como la 칰nica fuente de verdad para la creaci칩n y propagaci칩n de `EventMetadata`.
-   **Implementaci칩n:**
    -   Inyectar치 el `RequestContextService`.
    -   **`createFromContext()`:** Crear치 la metadata inicial para el primer paso de una saga, extrayendo el `actor` y `correlationId` del `RequestContextService`.
    -   **`createFromPrevious(previousMetadata)`:** Crear치 la metadata para un paso subsiguiente de la saga, recibiendo la metadata del evento anterior. Copiar치 el `correlationId` y el `actor`, y establecer치 el `causationId` con el ID del evento anterior.

### 3.3. El Sistema de Decoradores

Este es el n칰cleo de la interacci칩n del desarrollador con el m칩dulo.

#### 3.3.1. Decorador de M칠todo: `@EmitsEvent(options)`

-   **Prop칩sito:** Declarar que un m칠todo emite eventos y automatizar su emisi칩n.
-   **Firma:**
    ```typescript
    interface EventInfo {
      name: string;
      description?: string;
      payload: new (...args: any[]) => any;
    }

    interface EmitsEventOptions {
      onSuccess: EventInfo;
      onFailure?: EventInfo;
    }

    function EmitsEvent(options: EmitsEventOptions): MethodDecorator;
    ```
-   **Comportamiento ("Magia"):**
    1.  Envuelve el m칠todo original en un bloque `try/catch`.
    2.  Antes de ejecutar, determina la metadata correcta (ver secci칩n 3.3.2 y 3.3.3).
    3.  **En caso de 칠xito:** Llama a `eventEmitter.emit()` con el `name` y `payload` definidos en `onSuccess`. El resultado del m칠todo original se empaqueta dentro del `data` del payload.
    4.  **En caso de excepci칩n:** Llama a `eventEmitter.emit()` con los datos de `onFailure`. El `error` capturado se empaqueta en el `data` del payload.
    5.  Toda la l칩gica de creaci칩n de `EventPayload` y llamada a `eventEmitter` est치 oculta al desarrollador.

#### 3.3.3. Decorador de M칠todo: `@OnEventDoc(eventName, options)`

-   **Prop칩sito:** Reemplazar el `@OnEvent` de NestJS para no solo suscribir un m칠todo a un evento, sino tambi칠n para registrar esta relaci칩n, permitiendo la generaci칩n de documentaci칩n y grafos de flujo.
-   **Firma:**
    ```typescript
    interface OnEventDocOptions {
      description?: string;
    }

    function OnEventDoc(eventName: string, options?: OnEventDocOptions): MethodDecorator;
    ```
-   **Comportamiento:**
    1.  Internamente, llama al decorador `@OnEvent(eventName)` de `@nestjs/event-emitter` para asegurar la funcionalidad de suscripci칩n.
    2.  Utiliza `Reflect.defineMetadata` para registrar en un `SagaRegistryService` global que la clase y m칠todo actuales est치n escuchando a `eventName`, junto con la `description` proporcionada.

#### 3.3.4. Decorador de Par치metro: `@CausationEvent()`

-   **Prop칩sito:** Marcar expl칤citamente qu칠 par치metro de un m칠todo listener contiene el `EventPayload` del evento que lo caus칩.
-   **Comportamiento:**
    -   No tiene l칩gica propia. Su 칰nica funci칩n es adjuntar metadatos (`Reflect.defineMetadata`) al m칠todo, indicando la posici칩n del par치metro que es el evento causante. El decorador `@EmitsEvent` leer치 estos metadatos para saber de d칩nde extraer la metadata a propagar.

#### 3.3.5. Decorador de Par치metro: `@EventMetadata()`

-   **Prop칩sito:** Inyectar el objeto `EventMetadata` directamente en un par치metro del m칠todo para que el desarrollador pueda usarlo si lo necesita.
-   **Comportamiento:**
    -   Similar a `@CausationEvent`, marca un par치metro.
    -   El decorador `@EmitsEvent` identificar치 este par치metro y, despu칠s de calcular la metadata para el paso actual, la inyectar치 en este argumento antes de llamar al m칠todo original.

### 3.4. `EventLogService`

-   **Prop칩sito:** Proporcionar un log de auditor칤a completo de todos los eventos que ocurren en el sistema.
-   **Implementaci칩n:**
    -   Contendr치 un 칰nico listener wildcard: `@OnEvent('*', { async: true })`.
    -   Al recibir un evento, lo escribir치 en un archivo `event-log.json`. Cada evento se a침adir치 a una nueva l칤nea para simular un log inmutable.
    -   Esto simula una persistencia real en una base de datos sin la complejidad de configurar una para este prototipo.

### 3.5. Interfaces y DTOs Base

-   Se definir치n estructuras de datos clave en archivos compartidos:
    -   `Actor`: `{ id: string; type: 'user' | 'system'; details?: Record<string, any> }`
    -   `EventMetadata`: `{ eventId: string; correlationId: string; causationId: string | null; timestamp: Date; actor: Actor }`
    -   `EventPayload<T>`: `{ data: T; metadata: EventMetadata }`

## 4. Flujo de Trabajo del Desarrollador (Modo de Uso)

### Paso 1: Iniciar una Saga (desde un Controlador HTTP)

El desarrollador no necesita hacer nada especial. Un middleware global configurado por el m칩dulo se encarga de todo.

```typescript
// src/modules/users/user.controller.ts
@Controller('users')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Post()
  async createUser(@Body() body: CreateUserDto) {
    // La firma del m칠todo est치 limpia. No hay par치metros de metadata.
    // El middleware ya pobl칩 AsyncLocalStorage.
    return this.userService.createUser(body);
  }
}

// src/modules/users/user.service.ts
@Injectable()
export class UserService {
  
  @EmitsEvent({
    onSuccess: { name: 'user.creation.success', payload: UserCreationSuccessPayload },
    onFailure: { name: 'user.creation.failed', payload: UserCreationFailurePayload },
  })
  async createUser(data: CreateUserDto) {
    // L칩gica de negocio pura.
    // No hay try/catch, no hay eventEmitter.emit.
    // El decorador se encarga de todo.
    const user = await this.userRepository.create(data);
    return { user }; // Este ser치 el `data` del payload de 칠xito.
  }
}
```

### Paso 2: Continuar la Saga (desde un Listener de Eventos)

Otro servicio escucha el evento de 칠xito y contin칰a la saga.

```typescript
// src/modules/notifications/notification.service.ts
@Injectable()
export class NotificationService {

  @OnEvent('user.creation.success')
  @EmitsEvent({
    onSuccess: { name: 'notification.welcome_email.sent', payload: EmailSentPayload },
  })
  async sendWelcomeEmail(
    // El desarrollador declara expl칤citamente sus dependencias de contexto:
    @CausationEvent() event: EventPayload<UserCreationSuccessPayload>,
    @EventMetadata() metadata: EventMetadata,
  ) {
    // El c칩digo es limpio, tipado y expl칤cito.
    console.log(`Continuando saga con correlationId: ${metadata.correlationId}`);
    
    const userEmail = event.data.user.email;
    // ...l칩gica para enviar el email.
    
    return { messageId: 'xyz-123' }; // `data` para el evento 'notification.welcome_email.sent'
  }
}
```

## 5. Generaci칩n de Artefactos (Tipos y Documentaci칩n)

Para evitar la complejidad de manipular el AST de TypeScript, se seguir치 un enfoque basado en un registro en memoria (`SagaRegistryService`).

1.  **Registro Global (`SagaRegistryService`):** Se crear치 un provider global que act칰e como un registro.
2.  **Poblado por Decoradores:** Cada vez que los decoradores `@EmitsEvent` y `@OnEventDoc` se inicialicen en la aplicaci칩n, registrar치n su informaci칩n (nombres de eventos, payloads, clases, m칠todos, descripciones) en el `SagaRegistryService`.
3.  **Script de Generaci칩n (`yarn nest generate-docs`):** Se crear치 un comando de NestJS. Este script arrancar치 una instancia "seca" de la aplicaci칩n para poblar el registro, y luego leer치 su contenido para generar los siguientes artefactos:
    -   **`generated-events.ts`**: Un archivo que exporta un objeto o enum con todos los nombres de eventos, proporcionando autocompletado y una fuente 칰nica de verdad para los nombres de eventos.
    -   **`EVENT_FLOW.md`**: Un documento Markdown que contiene un grafo del flujo de la saga en formato **Mermaid.js**. Esto permite que el grafo se renderice directamente en visores de Markdown como GitHub, proporcionando una documentaci칩n visual accesible sin necesidad de herramientas externas.
    -   **`EVENT_CATALOG.md`**: Un documento Markdown que sirve como un cat치logo de eventos, detallando la descripci칩n de cada uno, qui칠n lo emite y qui칠n lo escucha.

## 6. Plan de Implementaci칩n (Prueba de Concepto)

1.  Crear la estructura de directorios: `src/saga-event-module`.
2.  Definir las interfaces y DTOs base.
3.  Implementar `RequestContextService` y el middleware global.
4.  Implementar `EventMetadataHelper`.
5.  Implementar el sistema de decoradores (`@EmitsEvent`, `@CausationEvent`, `@EventMetadata`) usando `ReflectMetadata`.
6.  Implementar `EventLogService` con persistencia en un archivo JSON.
7.  Refactorizar `AppModule`, `AppController` y `AppService` para usar el nuevo m칩dulo y probar el flujo de extremo a extremo.
8.  Crear el script de generaci칩n de tipos.
